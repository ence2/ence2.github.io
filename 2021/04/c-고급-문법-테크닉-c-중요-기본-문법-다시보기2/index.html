<!DOCTYPE html>
<html lang="ko-kr">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.53 with theme Tranquilpeak 0.4.8-BETA">
<meta name="author" content="Developing life">
<meta name="keywords" content="tech, developer, 개발자, programmer, programming, software, 프로그래머, coding, 코딩, server, development, developer, 프로그래머, 개발자, 프로그래밍">
<meta name="description" content="C&#43;&#43; 버전과 역사에 대해서 알아보고, 기본 문법의 This call, New, Name mangling, Conversion 등에 대해 알아보겠습니다.">


<meta property="og:description" content="C&#43;&#43; 버전과 역사에 대해서 알아보고, 기본 문법의 This call, New, Name mangling, Conversion 등에 대해 알아보겠습니다.">
<meta property="og:type" content="article">
<meta property="og:title" content="C&#43;&#43; 고급 문법/테크닉 - C&#43;&#43; 중요 기본 문법 다시보기[2]">
<meta name="twitter:title" content="C&#43;&#43; 고급 문법/테크닉 - C&#43;&#43; 중요 기본 문법 다시보기[2]">
<meta property="og:url" content="https://ence2.github.io/2021/04/c-%EA%B3%A0%EA%B8%89-%EB%AC%B8%EB%B2%95-%ED%85%8C%ED%81%AC%EB%8B%89-c-%EC%A4%91%EC%9A%94-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B02/">
<meta property="twitter:url" content="https://ence2.github.io/2021/04/c-%EA%B3%A0%EA%B8%89-%EB%AC%B8%EB%B2%95-%ED%85%8C%ED%81%AC%EB%8B%89-c-%EC%A4%91%EC%9A%94-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B02/">
<meta property="og:site_name" content="Keep calm carry on">
<meta property="og:description" content="C&#43;&#43; 버전과 역사에 대해서 알아보고, 기본 문법의 This call, New, Name mangling, Conversion 등에 대해 알아보겠습니다.">
<meta name="twitter:description" content="C&#43;&#43; 버전과 역사에 대해서 알아보고, 기본 문법의 This call, New, Name mangling, Conversion 등에 대해 알아보겠습니다.">
<meta property="og:locale" content="en-us">

  
    <meta property="article:published_time" content="2021-04-15T10:50:00">
  
  
    <meta property="article:modified_time" content="2021-04-15T10:50:00">
  
  
  
    
      <meta property="article:section" content="Language">
    
      <meta property="article:section" content="C&#43;&#43;">
    
  
  
    
      <meta property="article:tag" content="C&#43;&#43;">
    
      <meta property="article:tag" content="Modern C&#43;&#43;">
    
      <meta property="article:tag" content="C&#43;&#43; Advanced">
    
  


<meta name="twitter:card" content="summary">











  <meta property="og:image" content="https://avatars1.githubusercontent.com/u/53330253?s=460&u=0f3d9c64f695413f8d31da697df4b8e2f77a2ef1&v=4">
  <meta property="twitter:image" content="https://avatars1.githubusercontent.com/u/53330253?s=460&u=0f3d9c64f695413f8d31da697df4b8e2f77a2ef1&v=4">


    <title>C&#43;&#43; 고급 문법/테크닉 - C&#43;&#43; 중요 기본 문법 다시보기[2]</title>

    <link rel="icon" href="https://ence2.github.io/favicon.png">
    

    

    <link rel="canonical" href="https://ence2.github.io/2021/04/c-%EA%B3%A0%EA%B8%89-%EB%AC%B8%EB%B2%95-%ED%85%8C%ED%81%AC%EB%8B%89-c-%EC%A4%91%EC%9A%94-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B02/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://ence2.github.io/css/style-3vvhladpcoxxi5xtg919g4jomaw4to5kaduclr4dto0uo6rhcutwzy9zd.min.css" />
    
    

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-183004637-2', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2434286165145936"
     crossorigin="anonymous"></script>
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="5">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://ence2.github.io/">Keep calm carry on</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://ence2.github.io/#about">
    
    
    
      
        <img class="header-picture" src="https://avatars1.githubusercontent.com/u/53330253?s=460&amp;u=0f3d9c64f695413f8d31da697df4b8e2f77a2ef1&amp;v=4" alt="Author&#39;s picture" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="5">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://ence2.github.io/#about">
          <img class="sidebar-profile-picture" src="https://avatars1.githubusercontent.com/u/53330253?s=460&amp;u=0f3d9c64f695413f8d31da697df4b8e2f77a2ef1&amp;v=4" alt="Author&#39;s picture" />
        </a>
        <h4 class="sidebar-profile-name">Developing life</h4>
        
          <h5 class="sidebar-profile-bio">다시 보기 위한 공간입니다.</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://ence2.github.io/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">Home</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link open-algolia-search" href="https://ence2.github.io/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-search"></i>
      
      <span class="sidebar-button-desc">Search</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://ence2.github.io/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">Categories</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/ence2" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.instagram.com/svr.dev/" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-instagram"></i>
      
      <span class="sidebar-button-desc">Instagram</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://ence2.github.io/index.xml">
    
      <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="5"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      C&#43;&#43; 고급 문법/테크닉 - C&#43;&#43; 중요 기본 문법 다시보기[2]
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2021-04-15T10:50:00&#43;09:00">
        
  April 15, 2021

      </time>
    
    
  
  
    <span>in</span>
    
      <a class="category-link" href="https://ence2.github.io/categories/language">Language</a>, 
    
      <a class="category-link" href="https://ence2.github.io/categories/c&#43;&#43;">C&#43;&#43;</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <p>C++ 버전과 역사에 대해서 알아보고, 기본 문법의 This call, New, Name mangling, Conversion 등에 대해 알아보겠습니다.</p>

<h3 id="about-c">About C++</h3>

<ul>
<li>www.isocpp.org : cpp 표준에서 운영하는 사이트</li>
<li>표준 cpp 발전 흐름 : C++<sup>98</sup>&frasl;<sub>04</sub> -&gt; C++11 -&gt; C++14 -&gt; C++17 -&gt; C++20</li>
</ul>

<p><img src="https://isocpp.org/files/img/wg21-timeline-2019-07.png" alt="" /></p>

<h3 id="this-call">This call</h3>

<ul>
<li><p>멤버함수의 호출원리</p>

<ul>
<li>멤버 함수는 1번째 인자로 객체의 주소(this) 가 암시적으로 추가된다. ( 개발자는 볼 수 없음 )</li>
<li>전달되는 객체의 주소는 ecx 레지스터로 전달</li>
<li>static 멤버 함수는 인자로 객체의 주소(this) 가 추가되지 않는다. 그리하여 static 멤버 함수는 멤버 변수에 접근 할 수 없는 오류가 발생하는 것(this가 없기 때문 but 우회하는 트릭이 있음)</li>
<li>멤버 함수에 this가 암시적으로 전달 되는 것을 this call이라고 함.</li>
</ul></li>
</ul>

<pre><code class="language-cpp">  class Point
  {
    int x = 0, y = 0;
  public:
    void set(int a, int b) // void set(Point* const this, int a, int b)
    {
        x = a;  // this-&gt;x = a;
        y = b;  // this-&gt;y = b;
    }
    static void foo(int a) // void foo( int a)
    {
        x = a;              // this-&gt;x = a;   변경해야 하는데.. this 가 없다. error
    }
  };
  // cl this1.cpp /FAs  =&gt; this1.asm
  // g++ this1.cpp -S   =&gt; this1.s
  int main()
  {
    Point::foo(10); // push 10
                    // call Point::foo
  
    Point p1;
    Point p2;
  
    // this call
    p1.set(10, 20); // set(&amp;p1, 10, 20)
                    // push 20
                    // push 10
                    // lea  ecx, &amp;p1    rcx, &amp;p1 // 객체 주소는 레지스터로
                    // call Point::set
  }
</code></pre>

<ul>
<li>멤버함수 포인터</li>
</ul>

<pre><code class="language-cpp">  // 핵심 1. 일반 함수 포인터에 멤버함수의 주소를 담을수 없다.
  // 핵심 2. 일반 함수 포인터에 static 멤버함수의 주소를 담을수 있다.
  // 핵심 3. 멤버 함수 포인터 모양과 사용법.  .*   (p-&gt;*f3)()
  
  class Dialog
  {
  public:
    void Close() {}
  };
  
  void foo() {}
  
  int main()
  {
    void(*f1)() = &amp;foo;
    f1();
  
  //    void(*f2)() = &amp;Dialog::Close; // error. this 가 추가되는 함수.
  
    void(Dialog::*f3)() = &amp;Dialog::Close; // ok.. 멤버 함수 포인터.
  
    //f3(); // error. 객체(this)가 없다.
  
    Dialog dlg;
    //dlg.f3(); // dlg.Close()의 의미.. 하지만..f3이라는 멤버를 찾게된다.- error
  
    //dlg.*f3(); // &quot;.*&quot; : pointer to member operator
                // error. 연산자 우선순위 문제..
  
    (dlg.*f3)(); // ok.. dlg.Close();   
  }
</code></pre>

<ul>
<li>예제 1 - Thread 클래스 만들기</li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  #include &lt;windows.h&gt;
  using namespace std;
  
  // 라이브러리 내부 클래스
  class Thread
  {
  public:
  
    void run()
    {
        CreateThread(0, 0, threadMain,(void*)this, 0, 0);
    }
  
    // 1. 아래 함수는 반드시 static 함수 이어야 합니다.
    // 2. 아래 함수는 this가 없다. 그래서 함수 인자로
    //    this를 전달하는 기술.
  
    static DWORD __stdcall threadMain(void* p)
    {
        Thread* const self = static_cast&lt;Thread*&gt;(p);
  
        self-&gt;Main(); // Main( self )
  
        //Main(); // 가상함수 호출
                // this-&gt;Main() =&gt; Main( this) 로 변해야 한다.
  
        return 0;
    }
  
    virtual void Main() // void Main(Thread* const this)
    {}
  };
  
  // 라이브러리 사용자 코드
  class MyThread : public Thread
  {
  public:
    virtual void Main() { cout &lt;&lt; &quot;스레드 작업&quot; &lt;&lt; endl; }
  };
  
  int main()
  {
    MyThread t;
    t.run();    // 이순간 스레드가 생성되어서 
                // 가상함수 Main()을 실행해야 합니다.
    getchar();
  }
</code></pre>

<ul>
<li>예제 2 - 타이머 개념을 사용해서 Clock 클래스 만들기</li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;map&gt;
  using namespace std;
  
  class Clock
  {
    static map&lt;int, Clock*&gt; this_map;
    string name;
  public:
    Clock(string n) : name(n) {}
  
    void start(int ms)
    {
        int id = set_timer(ms, timerHandler );
  
        this_map[id] = this;
    }
  
    // 핵심 1. 아래 함수는 반드시 static 멤버 이어야 합니다.
      // 인자가 1개 필요한데(id) non static 멤버 함수는 this가 암시적으로 전달 되기 때문
    static void timerHandler(int id)
    {
        Clock* const self = this_map[id];
  
        //cout &lt;&lt; name &lt;&lt; endl; // this-&gt;name
        cout &lt;&lt; self-&gt;name &lt;&lt; endl;
    }
  };
  
  map&lt;int, Clock*&gt; Clock::this_map;
  
  int main()
  {
    Clock c1(&quot;A&quot;);
    Clock c2(&quot;\tB&quot;);
  
    c1.start(1000); // 1000ms 에 한번씩 이름출력
    c2.start(500);  // 500ms 에 한번씩 이름출력
  
    process_message();
  }
</code></pre>

<ul>
<li>다중 상속과 this</li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  using namespace std;
  
  class A
  {
    int a;
  public:
    void fa() { cout &lt;&lt; this &lt;&lt; endl; }
  };
  
  class B
  {
    int b;
  public:
    void fb() { cout &lt;&lt; this &lt;&lt; endl; }
  };
  
  class C : public A, public B
  {
    int c;
  };
  
  int main()
  {
    C obj;
    cout &lt;&lt; &amp;obj &lt;&lt; endl; // 1000
      
    A* pA = &amp;obj;
    B* pB = &amp;obj; // &amp;obj + sizeof(A)
      
      obj.fa(); // fa(&amp;obj)   cout &lt;&lt; this =&gt; 1000
    obj.fb(); // fb(&amp;obj + sizeof(A)) cout &lt;&lt; this =&gt; 1004
  
    cout &lt;&lt; &amp;obj &lt;&lt; endl; // 1000 
    cout &lt;&lt; pA   &lt;&lt; endl; // 1000
    cout &lt;&lt; pB   &lt;&lt; endl; // 1004
      
      void (C::*f)(); // 멤버 함수 포인터 ( 크기가 다중상속 일 때 커질 수 있음 )
  
    cout &lt;&lt; sizeof(f) &lt;&lt; endl; // 32bit 환경에서 8
  
    f = &amp;C::fa; // f = { fa 주소, 0  };
    f = &amp;C::fb; // f = { fb 주소, sizeof(A)};
  
    (obj.*f)(); // f.함수주소( &amp;obj + f.this offset )
  }
</code></pre>

<ul>
<li>멤버 변수 포인터</li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  using namespace std;
  
  class Point
  {
  public:
    int x, y;
  };
  
  int main()
  {
    int   n = 10;
    int* p1 = &amp;n;
  
    //void(Point::*f)() = &amp;Point::print; // 멤버 함수 포인터
    
    int Point::*p2 = &amp;Point::x; // 멤버 변수 포인터
                                // 0
    int Point::*p3 = &amp;Point::y; // 4
                                // C의 offset_of
  
    //cout &lt;&lt; p3 &lt;&lt; endl;
    printf(&quot;%d, %d\n&quot;, p2, p3);
  
    Point pt;
  
    pt.y = 10;
    pt.*p3 = 20;
  
    cout &lt;&lt; pt.y &lt;&lt; endl; // 20
  }
</code></pre>

<h3 id="const-member-function">Const Member Function</h3>

<ul>
<li><p>상수 멤버 함수의 필요성 : 변수 값을 변경하지 않는 모든 &ldquo;멤버 함수&rdquo;는 &ldquo;상수 멤버함수&rdquo;를 권장</p>

<ol>
<li>const 객체를 사용하는 코드에서 대상의 구현이 .h와 .cpp로 나눠져 있을 때 .h 파일만 include 하여도 상수 멤버 함수 속성을 통해 에러를 발생시킬 지 판단 가능</li>
</ol>

<pre><code class="language-cpp"> #include &lt;iostream&gt;
 using namespace std;
     
 class Point
 {
 public:
    int x, y;
     
    Point(int a = 0, int b = 0) : x(a), y(b) {}
     
    void set(int a, int b) 
    {
        x = a; 
        y = b; 
    }
    void print()  //const   // const를 붙이면 상수 멤버 함수
    {
    //  x = 10; // error. 모든 멤버를 상수 취급한다.
     
        cout &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; endl;
    }
 };
     
 int main()
 {
    const Point p(1, 1);
     
    p.x = 10;       // error
    p.set(10, 20);  // error
    p.print();      // ok or error.
 }
</code></pre>

<ol>
<li>상수 객체는 상수 멤버 함수만 호출 가능</li>
</ol>

<pre><code class="language-cpp"> // 객체의 상태를 변경하지 않은 모든 멤버함수는(getxxx)
 // 반드시 const 멤버 함수가 되어야 한다.
 struct Rect
 {
    int ox, oy, width, height;
     
    Rect(int x = 0, int y = 0, int w = 0, int h = 0) 
        : ox(x), oy(y), width(w), height(h) {}
     
    int getArea() const {   return width * height; }
 };
     
 void foo(  const Rect&amp; r) // call by value 보다는 const &amp; 가 좋다.
 {
    int n = r.getArea(); // error.
 }
     
 int main()
 {
    Rect r(0, 0, 10, 10);
     
    int n = r.getArea(); // ok.
     
    foo(r);
 }
</code></pre></li>

<li><p>논리적 상수성 : 상수 멤버 함수에서 변할 수 있는 대상을 지정 할 수 있음</p>

<ol>
<li>mutable 키워드 사용</li>
</ol></li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  using namespace std;
  
  class Point
  {
    int x, y;
  
    // mutable  멤버 변수 : 상수멤버함수 안에서도 값을 변경가능.
    mutable char cache[16];
    mutable bool cache_valid = false;
  public:
    Point(int a = 0, int b = 0) : x(a), y(b) {}
    
    // 캐싱된 값을 사용하는 상수 멤버함수 toString 구현
    const char* toString() const
    {
        if (cache_valid == false)
        {
            sprintf(cache, &quot;%d, %d&quot;, x, y);
            cache_valid = true;
        }
        return cache;
    }
  };
  
  int main()
  {
    Point p1(1, 1);
  
    cout &lt;&lt; p1.toString() &lt;&lt; endl;
    cout &lt;&lt; p1.toString() &lt;&lt; endl;
  
  }
</code></pre>

<ol>
<li>데이터 객체 포인터 사용</li>
</ol>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  using namespace std;
  
  struct Cache
  {
    char cache[16];
    bool cache_valid = false;
  };
  
  class Point
  {
    int x, y;
    Cache* pCache;
  public:
    Point(int a = 0, int b = 0) : x(a), y(b) 
    {
        pCache = new Cache;
    }
  
    const char* toString() const
    {
        if (pCache-&gt;cache_valid == false)
        {
            sprintf(pCache-&gt;cache, &quot;%d, %d&quot;, x, y);
            pCache-&gt;cache_valid = true;
        }
        return pCache-&gt;cache;
    }
    ~Point() { delete pCache; }
  };
  
  int main()
  {
    Point p1(1, 1);
  
    cout &lt;&lt; p1.toString() &lt;&lt; endl;
    cout &lt;&lt; p1.toString() &lt;&lt; endl;
  }
</code></pre>

<h3 id="new">New</h3>

<ul>
<li><p>new vs operator new</p>

<ul>
<li>new : 메모리 할당 + 생성자 호출</li>
<li>operator new : 메모리만 할당</li>
<li>delete도 같은 방식으로 동작(소멸자 관련)</li>
</ul></li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  using namespace std;
  
  class Point
  {
    int x, y;
  public:
    Point()  { cout &lt;&lt; &quot;Point()&quot;  &lt;&lt; endl; }
    ~Point() { cout &lt;&lt; &quot;~Point()&quot; &lt;&lt; endl; }
  };
  
  int main()
  {
      /*
    // malloc : 메모리만 할당
    Point* p1 = (Point*)malloc(sizeof(Point));
    free(p1);
    // new : 메모리 할당 + 생성자 호출
    Point* p2 = new Point;  
    delete p2;                                  
    */
      
    Point* p1 = static_cast&lt;Point*&gt;(
                operator new(sizeof(Point)));
  
    operator delete(p1);
  }
</code></pre>

<ul>
<li>placement new : 생성자를 호출하기 위해 표준에서 만든 new</li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  using namespace std;
  
  class Point
  {
    int x, y;
  public:
    Point()  { cout &lt;&lt; &quot;Point()&quot; &lt;&lt; endl; }
    ~Point() { cout &lt;&lt; &quot;~Point()&quot; &lt;&lt; endl; }
  };
  
  /* cpp 표준에서 생성자를 호출하는 표현
  void* operator new(size_t sz, void* p)
  {
    return p;
  }
  */
  
  int main()
  {
    Point p;    
  
    //new Point; // 인자가 1개인 operator new()호출.
  
    new(&amp;p) Point; // 인자가 2개인 operator new()호출.
                    // 메모리 할당이 아닌 생성자를
                    // 명시적으로 호출하는 코드
    p.~Point(); 
  }
</code></pre>

<ul>
<li><p>생성자(소멸자)의 명시적 호출이 필요한 이유</p>

<ul>
<li>객체를 힙에 10개 만들 때 (활용 -&gt; stl의 vector 생성시)</li>
</ul></li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  using namespace std;
  
  class Point
  {
    int x, y;
  public:
    Point(int a, int b) : x(a), y(b) 
    {
        cout &lt;&lt; &quot;Point(int, int)&quot; &lt;&lt; endl;
    } 
  };
  
  int main()
  {
    // Point 객체를 힙에 한개 만들고 싶다.
    Point* p1 = new Point(0, 0); // ok.
  
  
    // Point 객체를 힙에 10개 만들고 싶다.
    //Point* p2 = new Point[10]; // error.
  
    // 1. 메모리만 먼저 힙에 할당
    Point* p2 = static_cast&lt;Point*&gt;(operator new(sizeof(Point) * 10));
    
    // 2. 할당한 메모리에 객체를 생성(생성자 호출)
    for (int i = 0; i &lt; 10; i++)
        new(&amp;p2[i]) Point(0,0);
  
  
    // 3. 소멸자 호출
    for (int i = 9; i &gt;= 0; i--)
        p2[i].~Point();
  
    // 4. 메모리 해지.
    operator delete(p2);
    
      // 활용 stl vector
    vector&lt;Point&gt; v(10, Point(0,0));
  }
</code></pre>

<ul>
<li>stl의 vector 관련 추가 설명 -&gt; 소멸자의 명시적 호출이 필요 한 케이스</li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  #include &lt;vector&gt;
  using namespace std;
  
  int main()
  {
    vector&lt;int&gt; v(10, 0);
    v.resize(7);
    cout &lt;&lt; v.size() &lt;&lt; endl; // 7
    cout &lt;&lt; v.capacity() &lt;&lt; endl; // 10
  
  
    // DBConnect : 생성자에서 DB 접속을 한다고 가정
    vector&lt;DBConnect&gt; v2(10);
  
    v2.resize(7); // 메모리는 제거하지 않지만
                  // 줄어든 객체의 소멸자는 호출해야한다
                
    v2.resize(8); // 새로운 객체에 대한 메모리는 있다
                  // 하지만 생성자를 호출해서
                  // 다시 DB 접속을 해야 한다.
  }
</code></pre>

<h3 id="name-mangling">Name mangling</h3>

<p>컴파일러가 심볼의 이름을 변경하는 현상</p>

<ul>
<li>name mangling : 함수 오버로딩, namespace, template</li>
</ul>

<pre><code class="language-cpp">  int square(int n)     // 어셈블리 함수 이름 : squarei()
  {
    return n * n;
  }
  
  double square(double d)   // squared()
  {
    return d * d;
  }
  
  int main()
  {
    square(3);      // squarei(3)
    square(3.3);    // squared(3.3)
  }
</code></pre>

<ul>
<li>extern &ldquo;C&rdquo; : C 컴파일러에서는 name mangling 규칙이 적용되지 않아 c 파일을 c++ 컴파일러에서 사용시 링킹 오류를 막기 위한 방법</li>
</ul>

<pre><code class="language-cpp">  // 함수 선언 헤더 파일에서 __cplusplus와 exten &quot;C&quot;를 조합해서 사용
  
  // square.h
  //extern &quot;C&quot; // C++ 컴파일러에게 C 처럼 해석해 달라.
  
  #ifdef __cplusplus
  extern &quot;C&quot; {
  #endif
  
    int square(int);
  
  #ifdef __cplusplus
  }
  #endif
</code></pre>

<ul>
<li>같은 이름의 함수와 함수주소</li>
</ul>

<pre><code class="language-cpp">  #include &lt;cstdio&gt;
  
  int square(int n)
  {
    return n * n;
  }
  double square(double d)   
  {
    return d * d;
  }
  void foo(int a) 
  {
  }
  
  int main()
  {
    //printf(&quot;%p\n&quot;, &amp;square); // error
  
    //printf(&quot;%p\n&quot;, static_cast&lt;int(*)(int)&gt;(&amp;square)); // ok.
  
    //auto p = &amp;square; // error
  
    int(*f)(int) = &amp;square; // ok
      
      void(*f1)(int) = &amp;foo; // ok. 함수 주소 꺼내기
    void(*f2)(int) = foo;  // 함수 이름은 함수 주소로 암시적 형변환
  
    typedef void(*PF)(int); // 함수 포인터 타입
    typedef void F(int);    // 함수 타입..
  
    cout &lt;&lt; typeid(&amp;foo).name() &lt;&lt; endl; // void(*)(int)
    cout &lt;&lt; typeid(foo).name() &lt;&lt; endl;  // void(int)
  }
</code></pre>

<h3 id="constructor">Constructor</h3>

<ul>
<li><p>생성자 호출순서</p>

<ol>
<li>자식 클래스 생성시 부모 클래스의 생성자가 먼저 호출된다.</li>
<li>부모 클래스의 생성자는 항상 디폴트 생성자가 호출된다.</li>
<li>부모 클래스의 디폴트 생성자가 없는 경우 자식 클래스 객체를 만들 수 없다.</li>
<li>부모 클래스의 다른 생성자를 호출하려면 자식 클래스 생성자의 초기화 리스트에서 명시해야 한다.</li>
</ol></li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  using namespace std;
  
  class Base
  {
  public:
  //    Base()      { cout &lt;&lt; &quot;B()&quot;    &lt;&lt; endl; }
    Base(int a) { cout &lt;&lt; &quot;B(int)&quot; &lt;&lt; endl; }
    ~Base()     { cout &lt;&lt; &quot;~B()&quot;   &lt;&lt; endl; }
  };
  
  class Derived : public Base
  {
  public:
    Derived()     : Base(0) { cout &lt;&lt; &quot;D()&quot; &lt;&lt; endl; }
    Derived(int a): Base(a) { cout &lt;&lt; &quot;D(int)&quot; &lt;&lt; endl; }
    ~Derived()     { cout &lt;&lt; &quot;~D()&quot; &lt;&lt; endl; }
  };
  
  int main()
  {
    //Derived d;
    Derived d(5);
  }
</code></pre>

<pre><code class="language-cpp">  class Point
  {
    int x, y;
  public:
  //    Point()             : x(0), y(0) {}
    Point(int a, int b) : x(a), y(b) {}
  };
  class Rect
  {
    Point p1;
    Point p2;
  public:
    Rect() : p1(0,0), p2(0,0) //: p1(), p2()
    {
    }
  };
  
  int main()
  {
    Rect r; // 순서 p1 생성자 -&gt; p2 생성자 -&gt; Rect 생성자
  }
</code></pre>

<ul>
<li><p>멤버를 가지고 있는 상속관계 생성자 호출 순서</p>

<ol>
<li>부모 클래스 멤버의 생성자</li>
<li>부모 클래스의 생성자</li>
<li>자식 클래스 멤버의 생성자</li>
<li>자식 클래스의 생성자</li>
</ol></li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  using namespace std;
  
  struct BM { BM() { cout &lt;&lt; &quot;BM()&quot; &lt;&lt; endl; } };
  struct DM { DM() { cout &lt;&lt; &quot;DM()&quot; &lt;&lt; endl; } };
  
  struct Base
  {
    BM bm;
    int x;
    Base() { cout &lt;&lt; &quot;Base()&quot; &lt;&lt; endl; }
  };
  
  struct Derived : public Base
  {
    DM dm;
    int y;
    Derived() : dm(), Base()
    {
        cout &lt;&lt; &quot;Derived()&quot; &lt;&lt; endl; 
    }
  };
  
  int main()
  {
    Derived d; // BM() -&gt; Base() -&gt; DM() -&gt; Derived()
  }
</code></pre>

<ul>
<li><p>생성자 호출순서 관련 주의사항</p>

<ul>
<li><code>mystream(int sz) : buf(sz), stream(buf) {}</code>이렇게 buf를 초기화 하는 것으로 표현 해도 절대적 초기화 순서에 의해 버그가 발생함</li>
</ul></li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  using namespace std;
  
  struct stream_buf
  {
    stream_buf(size_t sz) 
    { 
        cout &lt;&lt; &quot;stream_buf&quot; &lt;&lt; endl; 
    }
  };
  // 생성자로 버퍼를 받는 객체
  struct stream
  {
    stream(stream_buf&amp; buf) 
    {
        cout &lt;&lt; &quot;stream : using stream_buf&quot; &lt;&lt; endl; 
    }
  };
  
  // 버퍼를 가지고 있는 객체
  struct mystream : public stream
  {
    stream_buf buf;
  public:
    mystream(int sz) : buf(sz), stream(buf) {}
  };
  
  
  int main()
  {
  //    stream_buf buf(1024);
  //    stream st(buf);
  
    mystream mst(1024);
  }
</code></pre>

<ul>
<li><p>해결 방법, 관리 클래스 만들고 다중상속을 이용해서 초기화 순서를 제어 (cpp 표준 스트림에서 사용 방식)</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
    
struct stream_buf
{
    stream_buf(size_t sz)
    {
        cout &lt;&lt; &quot;stream_buf&quot; &lt;&lt; endl;
    }
};
struct stream
{
    stream(stream_buf&amp; buf)
    {
        cout &lt;&lt; &quot;stream : using stream_buf&quot; &lt;&lt; endl;
    }
};
    
struct buf_manager
{
protected:
    stream_buf buf;
public:
    buf_manager(size_t sz) : buf(sz) {}
};
    
struct mystream : public buf_manager, public stream
{
public:
    mystream(size_t sz) : buf_manager(sz), stream(buf) {}
};
    
    
int main()
{
    mystream mst(1024);
}
</code></pre></li>

<li><p>생성자에서는 가상함수가 동작하지 않음</p></li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  using namespace std;
  
  // 생성자에서는 가상함수가 동작하지 않는다.
  struct Base
  {
    Base() { goo(); }
    
  //    void foo() { goo(); }
    virtual void goo() { cout &lt;&lt; &quot;Base::goo&quot; &lt;&lt; endl; }
  };
  
  struct Derived : public Base
  {
    int x;
  
    Derived() : x(10) {}
    virtual void goo() { cout &lt;&lt; &quot;Derived::goo&quot; &lt;&lt; x &lt;&lt; endl; }
  };
  
  int main()
  {
    Derived d; // Base::goo
  }
</code></pre>

<ul>
<li><p>생성자와 예외</p>

<ul>
<li>생성자에서 예외가 발생 할 경우 소멸자가 호출되지 않음( 문제 : 메모리 누수 발생 가능 )</li>
</ul></li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  using namespace std;
  
  struct Resource
  {
    Resource()  { cout &lt;&lt; &quot;acquire Resource&quot; &lt;&lt; endl; }
    ~Resource() { cout &lt;&lt; &quot;release Resource&quot; &lt;&lt; endl; }
  };
  
  class Test
  {
    Resource* p;
  public:
    Test() : p( new Resource )
    {
        cout &lt;&lt; &quot;Test()&quot; &lt;&lt; endl;
        throw 1;
    }
    ~Test()
    {
        delete p;
        cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl;
    }
  };
  int main()
  {
    try
    {
        Test t;
    }
    catch (...)
    {
        cout &lt;&lt; &quot;예외 발생&quot; &lt;&lt; endl;
    }
  }
</code></pre>

<ul>
<li>위 문제 해결 방법1 -&gt; 스마트 포인터 사용</li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  #include &lt;memory&gt;
  using namespace std;
  
  struct Resource
  {
    Resource() { cout &lt;&lt; &quot;acquire Resource&quot; &lt;&lt; endl; }
    ~Resource() { cout &lt;&lt; &quot;release Resource&quot; &lt;&lt; endl; }
  };
  
  class Test
  {
  //    Resource* p;
    unique_ptr&lt;Resource&gt; p;
  public:
    Test() : p(new Resource)
    {
        cout &lt;&lt; &quot;Test()&quot; &lt;&lt; endl;
        throw 1;
    }
    ~Test()
    {
        //delete p;
        cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl;
    }
  };
  
  int main()
  {
    try
    {
        Test t;
    }
    catch (...)
    {
        cout &lt;&lt; &quot;예외 발생&quot; &lt;&lt; endl;
    }
  }
</code></pre>

<ul>
<li>해결방법 2 -&gt; 예외 가능성이 있는 어떠한 작업도 하지 않음, ex) 자원 할당 전용 함수 구현
장점 : 가상 함수 사용 가능
단점 : 초기화 의미의 함수를 두번 작성해야함</li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  #include &lt;memory&gt;
  using namespace std;
  
  struct Resource
  {
    Resource() { cout &lt;&lt; &quot;acquire Resource&quot; &lt;&lt; endl; }
    ~Resource() { cout &lt;&lt; &quot;release Resource&quot; &lt;&lt; endl; }
  };
  
  // 해결책 2. two-phase constructor
  
  class Test
  {
    Resource* p;
  public:
    Test() : p(0)
    {
        // 예외 가능성이 있는 어떠한 작업도 하지 않는다.
        // 가상함수 호출()
    }
  
    // 자원 할당 전용함수
    void Construct()
    {
        p = new Resource;
        //cout &lt;&lt; &quot;Test()&quot; &lt;&lt; endl;
        // 가상함수 호출()
        throw 1;
    }
  
    ~Test()
    {
        delete p;
        cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl;
    }
  };
  
  
  int main()
  {
    try
    {
        Test t;
        t.Construct(); // 필요한 자원 할당.
    }
    catch (...)
    {
        cout &lt;&lt; &quot;예외 발생&quot; &lt;&lt; endl;
    }
  }
</code></pre>

<h3 id="trivial">Trivial</h3>

<ul>
<li><p>Trivial 개념</p>

<ul>
<li>하는 일이 없는 경우</li>
</ul></li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  #include &lt;type_traits&gt;
  using namespace std;
  
  class A
  {
  public:
    //virtual void foo() {} virtual 키워드를 붙일 경우 하는 일이 있는 것으로 봄
      virtual void foo() {}
  };
  
  int main()
  {
    cout &lt;&lt; is_trivially_constructible&lt;A&gt;::value &lt;&lt; endl;
  }
</code></pre>

<ul>
<li><p>Trivial 활용</p>

<ul>
<li>복사 생성자가 구현되있을 경우와 아닌 경우 처리를 다르게 하고 싶을 때 (객체 생성시 깊은복사, 얕은복사 선택 등)</li>
</ul></li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  #include &lt;type_traits&gt;
  using namespace std;
  
  template&lt;typename T&gt; void copy_type(T* dst, T* arc, int sz)
  {
    if (is_trivially_copyable&lt;T&gt;::value)
    {
        cout &lt;&lt; &quot;복사 생성자가 trivial&quot; &lt;&lt; endl;
        memcpy(dst, src, sizeof(T)*sz);
    }
    else
    {
        cout &lt;&lt; &quot;복사 생성자가 trivial 하지 않은 경우&quot; &lt;&lt; endl;
        while (sz--)
        {
            new(dst) T(*src);
            ++dst, ++src;
        }
    }
  }
  
  int main()
  {
      char s1[20] = &quot;hello world&quot;;
      char s2[20] = { 0 };
      
      copy_type(s1, s2, 20); // 모든 타입의 array를 복사하는 함수
  }
</code></pre>

<ul>
<li><p>Trivial로 판단되는 조건 정리</p>

<ul>
<li>virtual 함수가 아니어야 함</li>
<li>생성자가 없거나 구현되 있을 경우 default 키워드를 사용해야 함</li>
<li>객체형 멤버가 없거나, 객체 멤버의 생성자가 trivial 해야 함</li>
<li>상속 관계가 없거나, 부모 클래스의 생성자가 trivial 해야 함</li>
<li>멤버 변수 초기화 문법이 없어야함 ex) int a = 10;

<br /></li>
</ul></li>
</ul>

<h3 id="conversion">Conversion</h3>

<p>변환 연산자, 변환 생성자, explicit, nullptr 만들기 등</p>

<ul>
<li>변환연산자 : 사용자 타입 -&gt; 시스템 타입</li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  using namespace std;
  
  class Point
  {
    int x, y;
  public:
    Point()             : x(0), y(0) {}
    Point(int a, int b) : x(a), y(b) {}
  
    // 변환 연산자 : 객체를 다른 타입으로 변환할때 호출된다.
    // 특징 : 리턴 타입을 표기하지 않는다.
    operator int()
    {
        return x;
    }
  };
  
  int main()
  {
    int    n = 3;
    double d = n; // 암시적 형변환 발생.
  
    Point p1(1, 2);
    n = p1;     // 객체를 int에 대입할 때, 변환 연산자 필요 p1.operator int()
  
    cout &lt;&lt; n &lt;&lt; endl; // 1
  }
</code></pre>

<ul>
<li>변환 생성자 : 시스템 타입 -&gt; 사용자 타입</li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  using namespace std;
  
  // Point =&gt; int : 변환 연산자   p.operator int()
  // int =&gt; Point : 변환 생성자   Point(int)
  
  class Point
  {
    int x, y;
  public:
    Point()             : x(0), y(0) {}
    Point(int a, int b) : x(a), y(b) {}
  
    // 인자가 한개인 생성자 -  변환 생성자
    //                          다른 타입이 Point로 변환 되게 한다.
    Point(int a) : x(a), y(0) {}
  
    operator int()  { return x; }
  };
  
  int main()
  {
    Point p1;
    Point p2(1, 1);
  
    int n = 3;
    Point p(1, 2);
  
    n = p; // Point =&gt; int   p.operator int()
    p = n; // int =&gt; Point   n.operator Point() 가 있으면 된다.
           //                하지만, n은 사용자정의 타입이 아니다
  }
</code></pre>

<ul>
<li>변환의 장점</li>
</ul>

<p>사용자 정의 타입을 기존 라이브러리의 필요 파라메터로 전달 할 수 있음</p>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  using namespace std;
  // RAII : Resource Acquision Is Initialization
  class OFile
  {
    FILE* file;
  public:
    OFile(const char* filename, const char* mode = &quot;wt&quot;)
    {
        file = fopen(filename, mode);
    }
    ~OFile() {  fclose(file);   }
  
    operator FILE*() { return file; }
  };
  int main()
  {
    OFile f(&quot;a.txt&quot;);
  
    // C 함수를 사용해서 파일 작업
    fputs(&quot;hello&quot;, f);
    fprintf(f, &quot;n = %d&quot;, 10);   // OFile =&gt; FILE* 로 암시적 변환되면 가능.
                            // f.operator FILE*()
    
    String s1 = &quot;hello&quot;;
    char s2[10];
  
    strcpy(s2, s1); // String =&gt; const char* 암시적 변환..
  }
</code></pre>

<ul>
<li><p>변환의 단점</p>

<ul>
<li>의도하지 않은 변환이 발생되어 버그가 발생 할 수 있음</li>
</ul></li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  using namespace std;
  
  class OFile
  {
    FILE* file;
  public:
    // explicit 생성자 : 인자가 한개인 생성자가 암시적 변환을
    //                  허용하는 것을 막는다.
  
    explicit OFile(const char* filename, const char* mode = &quot;wt&quot;)
    {
        file = fopen(filename, mode);
    }
    ~OFile() { fclose(file); }
  
    operator FILE*() { return file; }
  };
  
  void foo(OFile f) {}
  
  int main()
  {
    OFile f(&quot;a.txt&quot;);
    foo(f); // ok..
  
    //foo(&quot;hello&quot;); // const char* =&gt; OFile 로 암시적 변환 발생.
                  // 변환 생성자
    //foo(static_cast&lt;OFile&gt;(&quot;hello&quot;));
  
  }
</code></pre>

<ul>
<li>explicit : 암시적 형변환 관련 처리를 제한 시킬 수 있음</li>
</ul>

<pre><code class="language-cpp">  class Test
  {
    int value;
  public:
    // explicit Test(int n) : value(n) {}
      Test(int n) : value(n) {}
  };
  
  int main()
  {
    // 아래 2줄의 차이점은 ?
    
    Test t1(5);  // 인자가 한개인 생성자 호출
                 // direct initialization
  
    Test t2 = 5; // 1. 변환 생성자를 사용해서 5를 가지고 Test의 임시객체 생성
                 // 2. 임시객체를 복사 생성자를 사용해서 t2에 복사
                 // copy initialization
                 // explicit 키워드를 사용하면 막을 수 있음
  }
</code></pre>

<pre><code class="language-cpp">  #include &lt;string&gt;
  #include &lt;memory&gt;
  using namespace std;
  
  class String16
  {
  public:
    explicit                    String16(const char16_t* o);
  };
  
  void foo(String16 s)  // String16 s = &quot;hello&quot;
  {}
  
  int main()
  {
    foo(&quot;hello&quot;); // error
    foo(String16(&quot;hello&quot;)); // ok..
  
  
    String16 s = &quot;hello&quot;; // error
  
    // STL 의 string 클래스는 생성자가 explicit 가 아님.
    string s1(&quot;hello&quot;);     // ok
    string s2 = &quot;hello&quot;;    // ok
  
  
    shared_ptr&lt;int&gt; p1 = new int;   // error  생성자가 explicit
    shared_ptr&lt;int&gt; p2(new int);    // ok..
  }
</code></pre>

<ul>
<li><p>nullptr 구현하기</p>

<ul>
<li>0에 관해 살펴보기</li>
</ul></li>
</ul>

<pre><code class="language-cpp">  int main()
  {
    int   n1 = 10; // ok
    void* p1 = 10; // error.
  
    int   n2 = 0; // ok
    void* p2 = 0; // ok. 0은 정수지만 포인터로 암시적 형변환된다.
  }
</code></pre>

<ul>
<li>전통적인 NULL 정의</li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  using namespace std;
  
  void foo(int n)   { cout &lt;&lt; &quot;int&quot; &lt;&lt; endl; }  // 1
  void foo(void* p) { cout &lt;&lt; &quot;void*&quot; &lt;&lt; endl; }    // 2
  
  void goo(char* p) { cout &lt;&lt; &quot;goo&quot; &lt;&lt; endl; }  // 3
  
  int main()
  {
    foo(0);         // 1
    foo((void*)0);  // 2
  
  #ifdef __cplusplus
    #define NULL    0
  #else
    #define NULL (void*)0
  #endif
  
    foo(NULL);      // 2
  
    goo(NULL);  // void* =&gt; char* 로의 암시적 변환 필요.
                // C   : ok
                // C++ : 암시적 변환 안됨.
  }
</code></pre>

<ul>
<li>전통적인 c++에서의 문제점 : 정수 0은 있으나, 포인터 0이 없음</li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  using namespace std;
  
  void foo(int n)   { cout &lt;&lt; &quot;int&quot; &lt;&lt; endl; }  // 1
  void foo(void* p) { cout &lt;&lt; &quot;void*&quot; &lt;&lt; endl; }    // 2
  void goo(char* p) { cout &lt;&lt; &quot;goo&quot; &lt;&lt; endl; }  // 3
  
  
  struct xnullptr_t
  {
    template&lt;typename T&gt;
    operator T*() { return 0; }
  };
  xnullptr_t xnullptr; // 포인터 0
  
  // C++ 11: xnullptr == nullptr
  int main()
  {
    foo(0);         // 1
    foo(xnullptr);  // 2. xnullptr_t =&gt; void* 로의 암시적 변환 필요..
                    //    xnullptr.operator void*()
    goo(xnullptr);  // 3 goo
  
    int n = 0;
    double* p1 = xnullptr;
  
    double* p2 = nullptr; // C++11 의 포인터 0
                          
    nullptr_t a = nullptr;
  
    int* p = a;
  }
</code></pre>

<ul>
<li>Return type resolver
좌변의 타입을 보고 우변의 리턴값을 결정 하는 방법</li>
</ul>

<pre><code class="language-cpp">  #include &lt;iostream&gt;
  #include &lt;cstdlib&gt;
  using namespace std;
  
  class memAlloc
  {
    int size;
  public:
    inline memAlloc(int sz) : size(sz) {}
  
    template&lt;typename T&gt; operator T*()
    {
        return (T*)malloc(size);
    }
  };
  
  int main()
  {
    double* p1 = memAlloc(40); // 클래스이름() : 임시객체, 함수가 아님
                               // 임시객체.operator double*()
    int*    p2 = memAlloc(40);
  
  }
</code></pre>

<ul>
<li>Safe bool : 객체를 조건문에 넣을 때 operator bool()로 암시적 형변환이 시도됨</li>
</ul>

<p>방법 1. bool 로 변환 - 단점. shift  연산이 허용된다.</p>

<blockquote>
<p>operator bool() { return fail() ? false : true; }</p>
</blockquote>

<p>방법 2. void* 로의 변환 - C++ <sup>98</sup>&frasl;<sub>03</sub></p>

<blockquote>
<p>operator void*() { return fail() ? 0 : this; }</p>
</blockquote>

<p>방법 3. 함수 포인터로의 변환.</p>

<blockquote>
<p>typedef void(*F)();
operator F() { return fail() ? 0 : &amp;true_function; }</p>
</blockquote>

<p>방법 4. 멤버 함수 포인터로의 변환. -&gt; Safe BOOL</p>

<pre><code class="language-cpp">  void true_function() {}
  
  class istream   // basic_istream
  {
  public:
    bool fail() { return false; }
  
    // 방법 1. bool 로 변환 - 단점. shift  연산이 허용된다.
    //operator bool() { return fail() ? false : true; }
  
    // 방법 2. void* 로의 변환 - C++ 98/03
    // operator void*() { return fail() ? 0 : this; }
  
    // 방법 3. 함수 포인터로의 변환.
    //typedef void(*F)();
    //operator F() { return fail() ? 0 : &amp;true_function; }
  
    // 방법 4. 멤버 함수 포인터로의 변환. - Safe BOOL
    //          if() 문에 넣을수 있는 side effect가 가장 적다..
    struct Dummy
    {
        void true_function() {}
    };
    typedef void(Dummy::*F)();
    operator F() { return fail() ? 0 : &amp;Dummy::true_function; }
  
  };
  istream cin;
  
  int main()
  {
    int n = 0;
    if ( cin ) {}
  //    cin &lt;&lt; n;
  //    delete cin;
  
  //    void(*f)() = cin;
  }
</code></pre>

<ul>
<li>Explicit Conversion Operator (safe bool을 간결하게 구현 가능)</li>
</ul>

<pre><code class="language-cpp">  class istream
  {
  public:
    bool fail() { return false; }
  
    // C++11 부터는 변환 연산자 앞에도 explicit를 붙일수 있다.
    // 암시적 변환은 error. 명시적 허용
    // if 문안에 객체를 넣을수도 있다.
    explicit operator bool() { return fail() ? false : true; }
  };
  istream cin;
  
  int main()
  {
    int n = 0;
  
    //bool b = cin; //error
    bool b = static_cast&lt;bool &gt; (cin); // ok
  
    //cin &lt;&lt; n; // error
  
    if ( cin ) {}  // ok
    if ( cin == false ) {}// error
  }
</code></pre>

<ul>
<li>Brace-init(일관된 초기화)과 변환</li>
</ul>

<pre><code class="language-cpp">  class Point
  {
    int x, y;
  public:
    explicit Point(int a, int b) : x(a), y(b) {}
  };
  
  void foo(Point p) {}
  
  int main()
  {
    foo({ 1,1 }); // error, explicit으로 인해
  
  //    Point p1(1, 1);
  
  //    Point p2{ 1, 1 };   // direct initialize (직접 초기화)
  
  //    Point p3 = { 1, 1 };// copy initialize. error (변환 생성 사용, explicit로 인해 error)
  }
</code></pre>

<p><a href="https://en.cppreference.com/w/">더 많은 C++ 관련 정보</a></p>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">TAGGED IN</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://ence2.github.io/tags/c&#43;&#43;/">C&#43;&#43;</a>

  <a class="tag tag--primary tag--small" href="https://ence2.github.io/tags/modern-c&#43;&#43;/">Modern C&#43;&#43;</a>

  <a class="tag tag--primary tag--small" href="https://ence2.github.io/tags/c&#43;&#43;-advanced/">C&#43;&#43; Advanced</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://ence2.github.io/2021/04/c-%EA%B3%A0%EA%B8%89-%EB%AC%B8%EB%B2%95-%ED%85%8C%ED%81%AC%EB%8B%89-c-11-14-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%953/" data-tooltip="C&#43;&#43; 고급 문법/테크닉 - C&#43;&#43; 11/14 기본 문법[3]">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://ence2.github.io/2021/04/c-%EA%B3%A0%EA%B8%89-%EB%AC%B8%EB%B2%95-%ED%85%8C%ED%81%AC%EB%8B%89-%EA%B0%9C%EC%9A%941/" data-tooltip="C&#43;&#43; 고급 문법/테크닉 - 개요[1]">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://ence2.github.io/2021/04/c-%EA%B3%A0%EA%B8%89-%EB%AC%B8%EB%B2%95-%ED%85%8C%ED%81%AC%EB%8B%89-c-%EC%A4%91%EC%9A%94-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B02/">
              <i class="fa fa-facebook-official"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://ence2.github.io/2021/04/c-%EA%B3%A0%EA%B8%89-%EB%AC%B8%EB%B2%95-%ED%85%8C%ED%81%AC%EB%8B%89-c-%EC%A4%91%EC%9A%94-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B02/">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https://ence2.github.io/2021/04/c-%EA%B3%A0%EA%B8%89-%EB%AC%B8%EB%B2%95-%ED%85%8C%ED%81%AC%EB%8B%89-c-%EC%A4%91%EC%9A%94-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B02/">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
                <div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2021 JhChoi. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://ence2.github.io/2021/04/c-%EA%B3%A0%EA%B8%89-%EB%AC%B8%EB%B2%95-%ED%85%8C%ED%81%AC%EB%8B%89-c-11-14-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%953/" data-tooltip="C&#43;&#43; 고급 문법/테크닉 - C&#43;&#43; 11/14 기본 문법[3]">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://ence2.github.io/2021/04/c-%EA%B3%A0%EA%B8%89-%EB%AC%B8%EB%B2%95-%ED%85%8C%ED%81%AC%EB%8B%89-%EA%B0%9C%EC%9A%941/" data-tooltip="C&#43;&#43; 고급 문법/테크닉 - 개요[1]">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://ence2.github.io/2021/04/c-%EA%B3%A0%EA%B8%89-%EB%AC%B8%EB%B2%95-%ED%85%8C%ED%81%AC%EB%8B%89-c-%EC%A4%91%EC%9A%94-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B02/">
              <i class="fa fa-facebook-official"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://ence2.github.io/2021/04/c-%EA%B3%A0%EA%B8%89-%EB%AC%B8%EB%B2%95-%ED%85%8C%ED%81%AC%EB%8B%89-c-%EC%A4%91%EC%9A%94-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B02/">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https://ence2.github.io/2021/04/c-%EA%B3%A0%EA%B8%89-%EB%AC%B8%EB%B2%95-%ED%85%8C%ED%81%AC%EB%8B%89-c-%EC%A4%91%EC%9A%94-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B02/">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="5">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fence2.github.io%2F2021%2F04%2Fc-%25EA%25B3%25A0%25EA%25B8%2589-%25EB%25AC%25B8%25EB%25B2%2595-%25ED%2585%258C%25ED%2581%25AC%25EB%258B%2589-c-%25EC%25A4%2591%25EC%259A%2594-%25EA%25B8%25B0%25EB%25B3%25B8-%25EB%25AC%25B8%25EB%25B2%2595-%25EB%258B%25A4%25EC%258B%259C%25EB%25B3%25B4%25EA%25B8%25B02%2F">
          <i class="fa fa-facebook-official"></i><span>Share on Facebook</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=https%3A%2F%2Fence2.github.io%2F2021%2F04%2Fc-%25EA%25B3%25A0%25EA%25B8%2589-%25EB%25AC%25B8%25EB%25B2%2595-%25ED%2585%258C%25ED%2581%25AC%25EB%258B%2589-c-%25EC%25A4%2591%25EC%259A%2594-%25EA%25B8%25B0%25EB%25B3%25B8-%25EB%25AC%25B8%25EB%25B2%2595-%25EB%258B%25A4%25EC%258B%259C%25EB%25B3%25B4%25EA%25B8%25B02%2F">
          <i class="fa fa-twitter"></i><span>Share on Twitter</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=https%3A%2F%2Fence2.github.io%2F2021%2F04%2Fc-%25EA%25B3%25A0%25EA%25B8%2589-%25EB%25AC%25B8%25EB%25B2%2595-%25ED%2585%258C%25ED%2581%25AC%25EB%258B%2589-c-%25EC%25A4%2591%25EC%259A%2594-%25EA%25B8%25B0%25EB%25B3%25B8-%25EB%25AC%25B8%25EB%25B2%2595-%25EB%258B%25A4%25EC%258B%259C%25EB%25B3%25B4%25EA%25B8%25B02%2F">
          <i class="fa fa-google-plus"></i><span>Share on Google&#43;</span>
        </a>
      </li>
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://avatars1.githubusercontent.com/u/53330253?s=460&amp;u=0f3d9c64f695413f8d31da697df4b8e2f77a2ef1&amp;v=4" alt="Author&#39;s picture" />
    
    <h4 id="about-card-name">Developing life</h4>
    
      <div id="about-card-bio">다시 보기 위한 공간입니다.</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        Game Developer
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        South Korea
      </div>
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://ence2.github.io/images/cover.jpg');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://ence2.github.io/js/script-cs3dg32dbvpminyyazkkqhrzxpbqj1rq9shogay7ajhhibfcghlcs7u1wqfo.min.js"></script>


<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
      <script>
        var disqus_config = function () {
          this.page.url = 'https:\/\/ence2.github.io\/2021\/04\/c-%EA%B3%A0%EA%B8%89-%EB%AC%B8%EB%B2%95-%ED%85%8C%ED%81%AC%EB%8B%89-c-%EC%A4%91%EC%9A%94-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B02\/';
          
            this.page.identifier = '\/2021\/04\/c-%EA%B3%A0%EA%B8%89-%EB%AC%B8%EB%B2%95-%ED%85%8C%ED%81%AC%EB%8B%89-c-%EC%A4%91%EC%9A%94-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-%EB%8B%A4%EC%8B%9C%EB%B3%B4%EA%B8%B02\/'
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'ence2-github-io';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  




    
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2434286165145936"
     crossorigin="anonymous"></script>
  </body>
</html>

